05.09.20. Лекция 1
=====
Жирков Игорь Олегович
-----
Формы контроля:
- зачет (сдать 2 рубежки (8 вопросов с ответами в свободной форме + 2 вопроса написать программу) + лабы)
-----
http://gitlab.rubber-duck-typing.com:4813/low-level-programming 
http://gitlab.rubber-duck-typing.com:4813/low-level-programming/classes - информация по лекциям
в вики - вся инфа по курсу: http://gitlab.rubber-duck-typing.com:4813/low-level-programming/classes/-/wikis/%D0%9A%D1%83%D1%80%D1%81-%22%D0%9D%D0%B8%D0%B7%D0%BA%D0%BE%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D0%B5%D0%B2%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%22 
-----
На практике каждой будет мини-тестик.
Чтобы делать лабы: винда с wsl, или линукс (или с виртуалкой) - все есть по ссылкам.
-----
Команды выполняются последовательно (1 за другим:
    a = b + 5;
    b = c - 3;
)
НО в целях оптимизации программа может переставлять.
-
В си (и плюсах) локальные переменные в стеке хранятся. В СТАНДАРТЕ СИ слово стек не упоминается ни 1 раз. С точки зрения стандарта: мы не знаем, знаем только то, что если выделяется, то подчиняется автоматической модели управления. И если живут, то точно живут автоматическое время функции.
-
Указатели на инт и флоат могут указывать на 1 переменную
===
За эту лекцию мы поймем, что такое вычислительная система (ну или хотябы получим представление об этом)? И получим представление о различии низкоуровневого программирования и высокоуровневого.
--
Система - набор компонентов, которые взаимодействуют и что-то дают в итоге. (органы - набор компонентов, человек - система).
Вычислительная системы могут быть сделаны не человеком даже сделаны (например, пульсары - быстровращающиеся звезды, излучение меняется но со стабильным периодом - можно юзать как часы).
--
Компоненты можно выделять структурно и функционально: 
    * Ножницы - структурно: две половинки + болт, функционально: 2 части - держать и резать (при этом нож функционально состоит из тех же частей).
    * Курсор. МОжно перемещать с помощью тачпада и мышки. Сам курсор - функциональная штука (конечная цель, для компьютера ввод с мышки, тачпада, программы - неразличим по сути). А вот сама мышь или тачпад - структурная компонента.
--
Сложность системы. Что такое сложная система?
1) Сложно описать
2) Сложно создать
3) Очень нерегулярная (точно описать и описание применять ко всем частям)
К тому же, если систему конструирует много людей - это уже что-то значит.
-
Принципы:
- модульность (создать кусочки, и из них уже собрать: понимая как работают куски, легче создать чтото целое, сложное)
- абстракция - структурная единица, но я буду забывать как устроен изнутри, я буду думать, как он выглядит извне.
=> С помощью этих 2 вещей можно организовать много вычислительных вещей, которые сейчас существуют.
Как охарактеризовать все курсы по специальности, используя <///>. --- ЕСть три функциональные категории
- исполнитель
- память
- транспорт
--
Фон-Нейман: есть процессор и память, и связь (проводочек) (а там есть уже пристонская и гарвардская архитектура).
1) Во что можно записать, и прочитать из него (ЖД, RAM (оперативная и виртуальная память), регистры (процессора), триггеры, Базы данных, кэши, перфокарта, облачные хранилища
2) Исполнитель - штука, которая выполняет команды, или реагирует на внешние раздражители: процессор, система WOR (реагирует на то, что мы делаем с ней), интерпретатор, компьютерные игры, браузер, тригеры, калькулятор (там и память есть)
3) Транспорт: провода, кабели, излучение, юникс каналы, интернет (любые сетевые протоколы).
В фон-неймане 1 исполнитель, 1 транспорт, 1 память, но никто не мешает сделать нам много этих штук: смотреть картиночки в конспекте Игоря (там все функциональные схемы, а не структурные)
---
Так что же такое низкоуровневое программирование?
Мы должны зафиксировать 2 абстрактных вычислителя (джава и байткод для джавы; си и ???(ассмеблер - тут не уверен); пайтон и байткод для него.
Программа на хаскел совсем не похожа на машинный код, а программа на си чем-то похожа, больше уровень абстракции.
Котлин менее похож на байткод, чем джава ---  больше преобразований комплятора. 
В Си количество абстракций очень мало => легче все законтролить. 
Низкий уровень нужен в тех случаях, когда в случае преобразований, мы не можем управлять чем-то (на высоком уровне мы не можем сказать и изменить что-то в изменении хода, а на низком - можем. 
---
Недостаток фон неймана - неинтерактивная, замкнутая на себя система. Что добавить?
- обмен с внешним миром с помощью прерываний. Но, например, принтер работает медленнее, чем процессор, поэтому мы должны уметь от принтера переходить к выполнению обычной программы, и снова прерываться на принтер и т.д.
- память: быстрая и дорогая/ помедленнее и дешевле => организуем в несколько уровней
==
Почему это работает?
- Есть такое свойтсво: локальность: если мы использовали кусок памяти, значит скоро пойдем к соседям => будем кэшировать (регистры = кэши, их примерно 3 уровня)
==
Ущелье, узкое и длинное, есть жд. Если зашел поезд, то с другого конца придется ждать. 
1) расширить ущелье - ущелье длинное, задача дорогостоящая
2) можно в середине сделать доп путь (отвод) на который будет заходить в карман 1 из поездов. НО мы усложнили систему: есть ограничение на длину поезда, быть уверенным в коммуникабельности их и тд - так и в компуктерах
---
Компьютер выполняет сразу МНОГО программ, которые делят программу между собой. Чтобы все решить - память виртуализируют (видимость, что она единственная и что она использует и проц, и память только она).
---
Лабы: сдаа через гитлаб. На пока структуры нет, сами лабы, да и курс по книжке Жиркова.
===================















Лекция 2. Исполнители))
Модель вычислений: мнабор базовых операций + их стоимость. - разные удобны для разных целей
Например, в джаве иф, объявление переменной ... - атомарные операции.
------
1. Лямбда-вычисления. Единица вычисления - строчка и просто переписывания их.
Строка - терм (объявление переменной, функции, применение функции
Прошарить чутка мне помогло: 
    * http://staff.ustc.edu.cn/~xyfeng/teaching/TOPL/lectureNotes/04_lambda.pdf
    * https://habr.com/ru/post/215807/
Функция следующее число для n:
\n.\f.\x.(f((n f) x))
(берем число).применение функции.к чемуто.
{(n f) x - n раз применить f к x}
{f((n f) x)- n раз применить f к x, а потом примени ее еще 1 раз}
--
т.е. все можно закодировать ТУПО с помоью функций (без чиселок).
Сила этой штуки - нет памяти, поэтому все хорошо вычисляется.
------
2. Макропроцессор.
.asm ---> (препроцессор) -> .asm -> .o
Для
%define x 10 (х заменить на 10)
%include "file" - все содержимое другого файла включат в этот
%ifdef ...
--
%define x move rax,
%define y rdx
x y => mov rax, rdx - с точки зрения ассемблера, мы не можем поделить, а для препроцессора - ок, это тупо текст.
(Т.Е. можно писать программу не для процессора, а для препроцессора - мы как раз лабы так и пишем)
nasm -E prime.asm ; делает файл, который нескомпилирован, но через который прошел препроцессор
ВО ВТОРОЙ лабе будем генерировать куски ассемблерных программ (тупо текстовые подстановки)
------
3. Конечные автоматы 
компьютер: реагирует на вход (умеет) И умеет выдавать реакции.
Компьютер стартует из начального состояния, наблюдает за событиями на входе, и переходит из одного состояния в другое, когда происходят какието события. 
Символы подаются на вход и печатаются на выход (сомволы - события).
--
Бывают неопределенности: если мы не описали действие для какихто инпутов. - можно, например, сделать состояние "Ошибка", а лучше, доопределить.
--
В Си: деление на ноль, выход за пределы массива (в си не проверяется)
--
Недетерминизм: не понятно, как именно будет вычисляться, но все будет окич.
--
Где использовать конечные автоматы: алгоритм для подсчета количества нулей в строчке, вычленения числа и тд.


























